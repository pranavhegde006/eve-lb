/*
 * Interface to libmerc
 */

#include "libmerc_api.h"
#include <iostream>

class libmerc_interface {
    libmerc_api mercury;
    libmerc_config config;
    mercury_context mc;
    const struct analysis_context *ctx;
    mercury_packet_processor mpp;

    static constexpr char libmerc_so_path[] = "./libmerc.so";
public:
    libmerc_interface() : mercury(libmerc_so_path) {
        config.resources="/home/pranhegd/Documents/new_10_2/envoy/dynamic_so/resources-mp.tgz";
        config.do_analysis = true;
    
        mc = mercury.init(&config, true);
        if (mc == nullptr) {
            throw std::runtime_error("mercury_init() returned null");
        }

        mpp = mercury.packet_processor_construct(mc);
        if (mpp == NULL) {
            fprintf(stderr, "error in mercury_packet_processor_construct()\n");
        }

    }

    const char *fingerprint_type_string(fingerprint_type fp_type) {
        switch(fp_type) {
        case fingerprint_type_unknown:     return "unknown";
        case fingerprint_type_tls:         return "tls";
        case fingerprint_type_tls_server:  return "tls_server";
        case fingerprint_type_http:        return "http";
        case fingerprint_type_http_server: return "http_server";
        case fingerprint_type_ssh:         return "ssh";
        case fingerprint_type_ssh_kex:     return "ssh_kex";
        case fingerprint_type_tcp:         return "tcp";
        case fingerprint_type_dhcp:        return "dhcp";
        case fingerprint_type_smtp_server: return "smtp_server";
        case fingerprint_type_dtls:        return "dtls";
        case fingerprint_type_dtls_server: return "dtls_server";
        case fingerprint_type_quic:        return "quic";
        default:
            ;
        }
        return "unregistered fingerprint type";
    }

    void fprint_analysis_context(FILE *f) {
        fprintf(f, "---------- start of %s ----------\n", __func__);
        if (ctx == NULL) {
            fprintf(f, "null analysis_context (no analysis present)\n");
        }
        enum fingerprint_type type = mercury.get_fingerprint_type(ctx);
        const char *fp_type_str = fingerprint_type_string(type);
        fprintf(f, "fingerprint_type: %s\n", fp_type_str);
        fprintf(f, "fingerprint_type_code: %u\n", type);

        const char *fp_string = mercury.get_fingerprint_string(ctx);
        if (fp_string) {
            fprintf(f, "fingerprint_string: %s\n", fp_string);
        } else {
            fprintf(f, "fingerprint_string: not present (null)\n");
        }

        const char *server_name = mercury.get_server_name(ctx);
        if (server_name) {
            fprintf(f, "server_name: %s\n", server_name);
        } else {
            fprintf(f, "server_name: not present (null)\n");
        }

        const char *probable_process = NULL;
        double probability_score = 0.0;
        if (mercury.get_process_info(ctx,
                                   &probable_process,
                                   &probability_score)) {
            fprintf(f,
                    "probable_process: %s\tprobability_score: %f\n",
                    probable_process,
                    probability_score);
        }
        bool probable_process_is_malware = false;
        double probability_malware = 0.0;
        if (mercury.get_malware_info(ctx,
                                   &probable_process_is_malware,
                                   &probability_malware)) {
            fprintf(f,
                    "probable_process_is_malware: %s\tprobability_malware: %f\n",
                    probable_process_is_malware ? "true" : "false",
                    probability_malware);
        }
        fprintf(f, "----------  end of %s  ----------\n", __func__);
    }

    void eval(uint8_t *data, size_t pkt_length) {
        struct timespec ts;
        timespec_get(&ts, TIME_UTC);
        ctx = mercury.get_analysis_context(mpp, data, pkt_length, &ts);
        fprint_analysis_context(stdout);
    }

    void get_malware_score(bool &is_malware, double &malware_score) {
        if (ctx == nullptr) {
        }        
    
        mercury.get_malware_info(ctx, &is_malware, &malware_score);
    }

    ~libmerc_interface() {
        // destroy packet processor
        //
        mercury.packet_processor_destruct(mpp);

        mercury.finalize(mc);
    }
};

int main() {
    libmerc_interface merc_interface;
     
    unsigned char client_hello_eth[] = {
  0x00, 0x50, 0x56, 0xe0, 0xb0, 0xbc, 0x00, 0x0c, 0x29, 0x74, 0x82, 0x2f,
  0x08, 0x00, 0x45, 0x00, 0x01, 0x61, 0xd5, 0xeb, 0x40, 0x00, 0x40, 0x06,
  0x58, 0x0c, 0xc0, 0xa8, 0x71, 0xed, 0x97, 0x65, 0x41, 0xa4, 0x80, 0x2a,
  0x01, 0xbb, 0xdd, 0x07, 0xfe, 0x40, 0x25, 0x00, 0x2e, 0x63, 0x50, 0x18,
  0xfa, 0xf0, 0x0c, 0xf3, 0x00, 0x00, 0x16, 0x03, 0x01, 0x01, 0x34, 0x01,
  0x00, 0x01, 0x30, 0x03, 0x03, 0x5b, 0x1f, 0x43, 0x3b, 0x2f, 0x09, 0x1c,
  0x61, 0xff, 0xd5, 0x1d, 0x3d, 0x8f, 0x00, 0x8f, 0xea, 0x86, 0x3f, 0xb6,
  0xc3, 0x72, 0x6e, 0x7f, 0x05, 0x6b, 0x01, 0x9e, 0xc7, 0x68, 0xcd, 0x12,
  0x58, 0x20, 0xf0, 0xa3, 0x04, 0x3a, 0x4f, 0x60, 0x89, 0x7b, 0x16, 0x89,
  0xf7, 0x46, 0xcf, 0x3c, 0x69, 0x03, 0xf9, 0xf6, 0x06, 0xa7, 0x7f, 0x53,
  0x36, 0xd4, 0xe2, 0x16, 0x33, 0xe9, 0x88, 0x48, 0xff, 0x14, 0x00, 0x3e,
  0x13, 0x02, 0x13, 0x03, 0x13, 0x01, 0xc0, 0x2c, 0xc0, 0x30, 0x00, 0x9f,
  0xcc, 0xa9, 0xcc, 0xa8, 0xcc, 0xaa, 0xc0, 0x2b, 0xc0, 0x2f, 0x00, 0x9e,
  0xc0, 0x24, 0xc0, 0x28, 0x00, 0x6b, 0xc0, 0x23, 0xc0, 0x27, 0x00, 0x67,
  0xc0, 0x0a, 0xc0, 0x14, 0x00, 0x39, 0xc0, 0x09, 0xc0, 0x13, 0x00, 0x33,
  0x00, 0x9d, 0x00, 0x9c, 0x00, 0x3d, 0x00, 0x3c, 0x00, 0x35, 0x00, 0x2f,
  0x00, 0xff, 0x01, 0x00, 0x00, 0xa9, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0e,
  0x00, 0x00, 0x0b, 0x6e, 0x79, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x2e, 0x63,
  0x6f, 0x6d, 0x00, 0x0b, 0x00, 0x04, 0x03, 0x00, 0x01, 0x02, 0x00, 0x0a,
  0x00, 0x0c, 0x00, 0x0a, 0x00, 0x1d, 0x00, 0x17, 0x00, 0x1e, 0x00, 0x19,
  0x00, 0x18, 0x00, 0x23, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x17,
  0x00, 0x00, 0x00, 0x0d, 0x00, 0x30, 0x00, 0x2e, 0x04, 0x03, 0x05, 0x03,
  0x06, 0x03, 0x08, 0x07, 0x08, 0x08, 0x08, 0x09, 0x08, 0x0a, 0x08, 0x0b,
  0x08, 0x04, 0x08, 0x05, 0x08, 0x06, 0x04, 0x01, 0x05, 0x01, 0x06, 0x01,
  0x03, 0x03, 0x02, 0x03, 0x03, 0x01, 0x02, 0x01, 0x03, 0x02, 0x02, 0x02,
  0x04, 0x02, 0x05, 0x02, 0x06, 0x02, 0x00, 0x2b, 0x00, 0x09, 0x08, 0x03,
  0x04, 0x03, 0x03, 0x03, 0x02, 0x03, 0x01, 0x00, 0x2d, 0x00, 0x02, 0x01,
  0x01, 0x00, 0x33, 0x00, 0x26, 0x00, 0x24, 0x00, 0x1d, 0x00, 0x20, 0x7f,
  0x36, 0x7d, 0x60, 0x25, 0x06, 0x55, 0xca, 0xbb, 0x18, 0xd3, 0x4c, 0x84,
  0xcc, 0x5b, 0x14, 0xcd, 0x0a, 0x95, 0xe9, 0x06, 0x13, 0x5d, 0xd7, 0x6a,
  0xee, 0x62, 0x2b, 0x2b, 0x54, 0x1c, 0x17
    };          
        
//    uint8_t *client_hello_ip = client_hello_eth + 14;
    size_t client_hello_len = sizeof(client_hello_eth);

    merc_interface.eval(client_hello_eth, client_hello_len);
    bool is_malware = false;
    double malware_score = 0.0;
    merc_interface.get_malware_score(is_malware, malware_score);
    std::cout << malware_score << std::endl;
    return 0;
};
